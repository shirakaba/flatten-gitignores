import fs from "node:fs";
import path from "node:path";
import * as process from "node:process";
import { parseArgs } from "node:util";

const {
  values: {
    ignoreFile: ignoreFile = ".gitignore",
    cwd: searchRoot,
    output: outputPath,
    prepend: prependPath,
    append: appendPath,
    exclude: excludePatterns,
    "no-default-excludes": noDefaultExcludes,
    help,
  },
} = parseArgs({
  options: {
    ignoreFile: { type: "string" },
    cwd: { type: "string" },
    output: { type: "string" },
    prepend: { type: "string" },
    append: { type: "string" },
    exclude: { type: "string", multiple: true },
    "no-default-excludes": { type: "boolean" },
    help: { type: "boolean" },
  },
});

if (help) {
  const usage = [
    "Usage: npx flatten-gitignores [--ignore-file] [--cwd <path>] [--output <file>]",
    "                              [--prepend <path>] [--append <path>] [--exclude <glob> ...]",
    "                              [--no-default-excludes] [--help]",
    "",
    "Flags (all optional):",
    '  --ignore-file <file>   The ignore file name to search for. Defaults to ".gitignore".',
    "  --cwd <path>           The search root / working directory; defaults to current CWD.",
    "  --output <file>        Output file path; defaults to <cwd>/.gitignore-collated.",
    "  --prepend <path>       Path to an additional ignore file to prepend.",
    "                         Resolved relative to CWD.",
    "  --append <path>        Path to an additional ignore file to append.",
    "                         Resolved relative to CWD.",
    "  --exclude <glob>       Glob(s) to exclude from the search for ignore files.",
    '                         Defaults to "**/node_modules/**".',
    "                         Pass one or more --exclude flags to add more.",
    "                         To omit the defaults, pass --no-default-excludes.",
    '  --no-default-excludes  Omit the default excludes ("**/node_modules/**").',
    "  --help                 Show this help message.",
    "",
    "Examples:",
    "  npx flatten-gitignores",
    "  npx flatten-gitignores --cwd ./packages/app",
    "  npx flatten-gitignores --output ./.easignore --prepend .easignore-prepend --append .easignore-append",
    "  npx flatten-gitignores --exclude **/dist/** --exclude **/build/**",
    "  npx flatten-gitignores --no-default-excludes",
    "  npx flatten-gitignores --ignore-file _gitignore",
  ].join("\n");
  console.log(usage);
  process.exit(0);
}

const cwd = searchRoot
  ? path.resolve(process.cwd(), searchRoot)
  : process.cwd();
const output = outputPath
  ? path.resolve(process.cwd(), outputPath)
  : path.resolve(cwd, ".gitignore-collated");

const flattened = flattenAllGitignores({
  cwd,
  prependPath,
  appendPath,
  excludePatterns: [
    ...(noDefaultExcludes ? [] : ["**/node_modules/**"]),
    ...(excludePatterns ?? []),
  ],
  ignoreFile,
});
fs.writeFileSync(output, flattened, "utf-8");

/**
 * Flatten all gitignores into a single one.
 *
 * @returns {string}
 */
function flattenAllGitignores({
  cwd,
  prependPath,
  appendPath,
  excludePatterns: exclude,
  ignoreFile,
}) {
  const patterns = [ignoreFile, `**/*/${ignoreFile}`];

  const entries = fs.globSync(patterns, {
    cwd,
    exclude,
    withFileTypes: true,
  });

  let prettierIgnore = [
    "################################################################################",
    "### This is a flattened ignore pattern list generated by flatten-gitignores. ###",
    "### See https://shirakaba/flatten-gitignores for documentation.              ###",
    "################################################################################",
    "",
    "",
  ].join("\n");

  if (prependPath) {
    const contents = fs.readFileSync(path.resolve(cwd, prependPath), "utf-8");
    const { dir, base } = path.parse(prependPath);
    prettierIgnore += formatIgnoreSection({ contents, dir, fileName: base });
  }

  for (const entry of entries) {
    if (!entry.isFile()) {
      continue;
    }

    const contents = fs.readFileSync(
      path.resolve(entry.parentPath, entry.name),
      "utf-8"
    );

    prettierIgnore += formatIgnoreSection({
      contents,
      dir: entry.parentPath,
      fileName: ignoreFile,
    });
  }

  if (appendPath) {
    const contents = fs.readFileSync(path.resolve(cwd, appendPath), "utf-8");
    const { dir, base } = path.parse(appendPath);
    prettierIgnore += formatIgnoreSection({ contents, dir, fileName: base });
  }

  return `${prettierIgnore.trim()}\n`;
}

function formatIgnoreSection({ contents, dir, fileName }) {
  const relativePath = path
    .relative(cwd, dir)
    .replace(/^\/*/, "/")
    .replace(/\/*$/, "/");

  let section = `### START ${relativePath}${fileName} ###\n`;
  const flattened = flattenGitignore({ contents, relativePath });
  section += `${flattened ?? "# (empty)"}\n`;
  section += `### END ${relativePath}${fileName} ###\n\n\n`;

  return section;
}

/**
 * A best-effort function to rewrite all gitignore rules to be relative to a
 * given path.
 *
 * @param {object} args
 * @param {string} args.contents
 * @param {string} args.relativePath A relative path, with both a leading and
 * trailing slash.
 *
 * @see https://git-scm.com/docs/gitignore#_pattern_format
 */
function flattenGitignore({ contents, relativePath }) {
  let flattened = "";

  for (const line of contents.split("\n")) {
    if (!line || line.startsWith("#")) {
      flattened += `${line}\n`;
      continue;
    }

    if (line.startsWith("/")) {
      // String-replace to avoid writing // redundantly.
      flattened += `${relativePath}${line.replace(/^\/+/, "")}\n`;
    } else {
      // String-replace to avoid writing /**/**/ redundantly.
      flattened += `${relativePath}**/${line.replace(/^\*\*\/*/, "")}\n`;
    }
  }

  return flattened.trim();
}

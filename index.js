import fs from "node:fs";
import path from "node:path";
import * as process from "node:process";
import { parseArgs } from "node:util";

const {
  values: {
    input: inputPath,
    output: outputPath,
    additions: additionsName,
    exclude: excludePatterns,
    help,
  },
} = parseArgs({
  options: {
    input: { type: "string" },
    output: { type: "string" },
    additions: { type: "string" },
    exclude: { type: "string", multiple: true },
    help: { type: "boolean" },
  },
});

if (help) {
  const usage = [
    "Usage: node index.js [--input <path>] [--output <file>]",
    "             [--additions <filename>] [--exclude <glob> ...] [--help]",
    "",
    "Options:",
    "  --input <path>       Input root for globbing; defaults to current CWD.",
    "  --output <file>      Output file path; defaults to <input>/.flattened-ignore.",
    "  --additions <name>   Optional additions file name to include (e.g. .prettierignore-additions).",
    "  --exclude <glob>     Glob(s) to exclude; pass multiple to add more (default: **/node_modules/**).",
    "  --help               Show this help message.",
    "",
    "Examples:",
    "  node index.js",
    "  node index.js --input ./packages/app",
    '  node index.js --additions .prettierignore-additions --exclude "**/dist/**" --exclude "**/build/**"',
    "  node index.js --output ./out/.flattened-ignore",
  ].join("\n");
  console.log(usage);
  process.exit(0);
}

const cwd = inputPath ? path.resolve(process.cwd(), inputPath) : process.cwd();
const output = outputPath
  ? path.resolve(process.cwd(), outputPath)
  : path.resolve(cwd, ".flattened-ignore");

const flattened = flattenAllGitignores({
  cwd,
  additionsName,
  excludePatterns: excludePatterns?.length
    ? excludePatterns
    : ["**/node_modules/**"],
});
fs.writeFileSync(output, flattened, "utf-8");

/**
 * Flatten all gitignores into a single one.
 *
 * @returns {string}
 */
function flattenAllGitignores({ cwd, additionsName, excludePatterns }) {
  const patterns = [".gitignore", "**/*/.gitignore"];

  // If an additions file name was provided, include it; otherwise omit.
  if (additionsName) {
    patterns.unshift(additionsName);
  }

  const entries = fs.globSync(patterns, {
    cwd,
    exclude: excludePatterns ?? ["**/node_modules/**"],
    withFileTypes: true,
  });

  let prettierIgnore = [
    "################################################################################",
    "### This is a flattened ignore pattern list generated by flatten-gitignores. ###",
    "### See https://shirakaba/flatten-gitignores for documentation.              ###",
    "################################################################################",
    "",
    "",
  ].join("\n");

  for (const entry of entries) {
    if (!entry.isFile()) {
      continue;
    }

    const contents = fs.readFileSync(
      path.resolve(entry.parentPath, entry.name),
      "utf-8"
    );

    // Create a relative path with a leading and trailing slash.
    const relativePath = path
      .relative(cwd, entry.parentPath)
      .replace(/^\/*/, "/")
      .replace(/\/*$/, "/");

    prettierIgnore += `### START ${relativePath}.gitignore ###\n`;

    const flattened = flattenGitignore({ contents, relativePath });

    prettierIgnore += `${flattened ?? "# (empty)"}\n`;

    prettierIgnore += `### END ${relativePath}.gitignore ###\n\n\n`;
  }

  return `${prettierIgnore.trim()}\n`;
}

/**
 * A best-effort function to rewrite all gitignore rules to be relative to a
 * given path.
 *
 * @param {object} args
 * @param {string} args.contents
 * @param {string} args.relativePath A relative path, with both a leading and
 * trailing slash.
 *
 * @see https://git-scm.com/docs/gitignore#_pattern_format
 */
function flattenGitignore({ contents, relativePath }) {
  let flattened = "";

  for (const line of contents.split("\n")) {
    if (!line || line.startsWith("#")) {
      flattened += `${line}\n`;
      continue;
    }

    if (line.startsWith("/")) {
      // String-replace to avoid writing // redundantly.
      flattened += `${relativePath}${line.replace(/^\/+/, "")}\n`;
    } else {
      // String-replace to avoid writing /**/**/ redundantly.
      flattened += `${relativePath}**/${line.replace(/^\*\*\/*/, "")}\n`;
    }
  }

  return flattened.trim();
}
